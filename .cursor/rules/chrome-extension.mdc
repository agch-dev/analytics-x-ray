---
description: Cross-browser extension architecture for Chrome and Firefox with manifest V3 patterns
globs: src/pages/background/**/*,src/pages/content/**/*,manifest.json,manifest.dev.json
alwaysApply: false
---

# Browser Extension Architecture (Chrome & Firefox)

This extension targets **both Chrome and Firefox** using Manifest V3. Always use browser-agnostic APIs and patterns.

## ⚠️ Critical: Use Browser-Agnostic APIs

```typescript
// ❌ NEVER use chrome.* APIs directly
chrome.runtime.sendMessage(msg);  // Wrong!
chrome.storage.local.get(key);    // Wrong!

// ✅ ALWAYS use webextension-polyfill
import Browser from 'webextension-polyfill';

Browser.runtime.sendMessage(msg);  // Correct!
Browser.storage.local.get(key);    // Correct!
```

The `webextension-polyfill` library provides a Promise-based API that works identically in Chrome and Firefox. This is **mandatory** for all extension API calls.

## Extension Contexts

### 1. Background Script (`src/pages/background/index.ts`)
- Runs as a service worker (MV3)
- Handles long-running operations
- Manages message passing between contexts
- **NO DOM access**
- Must handle service worker lifecycle (can be terminated/restarted)

### 2. Content Script (`src/pages/content/index.tsx`)
- Injected into web pages based on `matches` patterns
- Has access to page DOM but runs in isolated world
- Limited extension API access
- Communicates with background via `Browser.runtime.sendMessage`

### 3. Popup (`src/pages/popup/`)
- Shown when clicking extension icon
- Short-lived context (closes when losing focus)
- Full extension API access

### 4. DevTools Panel (`src/pages/panel/`)
- Shown in browser DevTools
- Best for detailed event inspection
- Long-lived while DevTools is open
- Registered via `src/pages/devtools/index.ts`

### 5. Options Page (`src/pages/options/`)
- Extension settings and configuration
- Full extension API access

## Message Passing Patterns

Always use `Browser` from `webextension-polyfill` for message passing:

```typescript
import Browser from 'webextension-polyfill';

// ✅ Content Script → Background
Browser.runtime.sendMessage({ 
  type: 'SEGMENT_EVENT', 
  payload: eventData 
});

// ✅ Background → Content Script (specific tab)
Browser.tabs.sendMessage(tabId, { 
  type: 'GET_EVENTS' 
});

// ✅ Listen for messages (works in all contexts)
Browser.runtime.onMessage.addListener((message, sender) => {
  console.log('Message from:', sender.tab?.url);
  return Promise.resolve({ received: true });
});
```

### Message Type Convention

```typescript
// Define message types in a shared types file
interface ExtensionMessage {
  type: 
    | 'SEGMENT_EVENT'      // New Segment event captured
    | 'GET_EVENTS'         // Request stored events
    | 'CLEAR_EVENTS'       // Clear event history
    | 'SETTINGS_UPDATED';  // Settings changed
  payload?: unknown;
}
```

## Manifest V3 Best Practices

### Permissions - Request Only What's Needed

```json
{
  "permissions": [
    "activeTab",     // Access current tab only when user interacts
    "storage"        // Store settings and event cache
  ],
  "host_permissions": [
    "<all_urls>"     // Required to inject content script everywhere
  ]
}
```

### Content Script Matching

```json
{
  "content_scripts": [{
    "matches": ["http://*/*", "https://*/*"],
    "js": ["src/pages/content/index.tsx"],
    "run_at": "document_start"  // Capture events early
  }]
}
```

## Cross-Browser Compatibility

### Build Targets

The project builds separate distributions for each browser:

```bash
# Development
yarn dev:chrome    # Builds to dist_chrome/
yarn dev:firefox   # Builds to dist_firefox/

# Production
yarn build:chrome  # Optimized Chrome build
yarn build:firefox # Optimized Firefox build
```

### webextension-polyfill Usage

```typescript
// ✅ Always import and use Browser (capital B)
import Browser from 'webextension-polyfill';

// All extension APIs are available on Browser.*
await Browser.runtime.sendMessage(msg);
await Browser.storage.local.get(key);
await Browser.tabs.query({ active: true, currentWindow: true });
await Browser.scripting.executeScript({ target: { tabId } });
```

### Browser-Specific Differences to Handle

| Feature | Chrome | Firefox | Solution |
|---------|--------|---------|----------|
| Side Panel | `chrome.sidePanel` | Not supported | Feature detect or exclude |
| Promise returns | Callback-based | Promise-based | Use polyfill (handles both) |
| Manifest icons | `action.default_icon` | Same | Works identically |
| Service worker | Full support | Full support (MV3) | Works identically |

### Feature Detection Pattern

```typescript
// ✅ Check for browser-specific features before using
async function openSidePanel() {
  // Side panel is Chrome-only
  if ('sidePanel' in Browser) {
    await (Browser as any).sidePanel.open({ windowId });
  } else {
    // Fallback for Firefox - open in popup or new tab
    await Browser.windows.create({ 
      url: 'panel.html', 
      type: 'popup' 
    });
  }
}
```

### Testing Both Browsers

Always test changes in both browsers:
1. Load `dist_chrome` in Chrome (`chrome://extensions`)
2. Load `dist_firefox` in Firefox (`about:debugging`)

## Error Handling

```typescript
// ✅ Handle extension context invalidation
async function sendToBackground(message: ExtensionMessage) {
  try {
    return await Browser.runtime.sendMessage(message);
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes('Extension context invalidated')) {
        // Extension was reloaded - inform user to refresh
        console.warn('Extension reloaded, please refresh the page');
        return null;
      }
      if (error.message.includes('Receiving end does not exist')) {
        // Background script not ready or content script not injected
        console.warn('Message receiver not available');
        return null;
      }
    }
    throw error;
  }
}
```

## Service Worker Lifecycle (Background Script)

```typescript
// ✅ Background scripts can be terminated - don't rely on in-memory state
// Use Browser.storage for persistence

// ❌ Bad - will be lost when service worker terminates
let events: SegmentEvent[] = [];

// ✅ Good - persist to storage
async function addEvent(event: SegmentEvent) {
  const { events = [] } = await Browser.storage.local.get('events');
  events.unshift(event);
  await Browser.storage.local.set({ 
    events: events.slice(0, 500) // Limit storage
  });
}
```

## Adding New Extension Pages

1. Create folder in `src/pages/[name]/`
2. Add `index.html`, `index.tsx`, `index.css`
3. Create main component as `[Name].tsx`
4. Update `manifest.json` if exposing the page
5. Update `vite.config.base.ts` if not auto-discovered

## Security Considerations

- Content scripts run in isolated world - use message passing
- Never use `eval()` or `new Function()` (CSP violation)
- Validate all data received from page context
- Don't expose sensitive APIs to web pages
