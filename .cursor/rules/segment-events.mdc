---
description: Segment analytics event interception and handling patterns
globs: src/pages/background/**/*,src/lib/segment.ts
alwaysApply: false
---

# Segment Event Interception (Network-Level)

## Architecture Overview

This extension captures Segment analytics events at the **network level** using Chrome's `webRequest` API. This approach intercepts the fully-enriched payloads that Segment actually sends over the wire, including all attributes added by the Segment SDK.

### Why Network-Level Interception?

| Approach | Pros | Cons |
|----------|------|------|
| `window.analytics` interception | Simple, immediate | Missing SDK-added fields: `messageId`, `anonymousId`, `sentAt`, `context.library` |
| **Network interception (used)** | Complete data, no page modification | Slightly delayed (after SDK processing) |

## Target Endpoints

Segment and compatible providers send data to these endpoints:

```typescript
// src/lib/segment.ts
export const SEGMENT_ENDPOINTS = [
  '*://api.segment.io/*',           // Segment
  '*://api.segment.com/*',          // Segment alternate
  '*://*.rudderstack.com/*',        // Rudderstack
  '*://tracking.dreamdata.cloud/*', // Dreamdata
] as const;
```

## Event Types

### Core Type Definitions

All types are defined in `src/lib/segment.ts`:

```typescript
// Segment event types
export type SegmentEventType =
  | 'track'
  | 'page'
  | 'screen'
  | 'identify'
  | 'group'
  | 'alias';

// Context added by Segment SDK (enriched data)
export interface SegmentContext {
  library: {
    name: string;      // e.g., "analytics.js"
    version: string;   // e.g., "4.1.0"
  };
  page?: {
    path: string;
    referrer: string;
    search: string;
    title: string;
    url: string;
  };
  userAgent?: string;
  locale?: string;
  timezone?: string;
  ip?: string;
  campaign?: Record<string, string>;
}

// Individual event in a Segment batch
export interface SegmentBatchEvent {
  type: SegmentEventType;
  event?: string;        // For track events
  name?: string;         // For page/screen events
  properties?: Record<string, unknown>;
  traits?: Record<string, unknown>;
  anonymousId?: string;
  userId?: string;
  messageId: string;     // Unique ID from Segment
  timestamp: string;     // ISO timestamp
  context: SegmentContext;
  integrations?: Record<string, boolean | Record<string, unknown>>;
}

// Full batch payload sent over network
export interface SegmentBatchPayload {
  batch: SegmentBatchEvent[];
  sentAt: string;
  writeKey?: string;
}

// Normalized event for extension display
export interface SegmentEvent {
  id: string;
  type: SegmentEventType;
  name: string;
  properties: Record<string, unknown>;
  traits?: Record<string, unknown>;
  anonymousId?: string;
  userId?: string;
  messageId: string;
  timestamp: string;
  sentAt: string;
  context: SegmentContext;
  integrations?: Record<string, boolean | Record<string, unknown>>;
  // Extension metadata
  tabId: number;
  capturedAt: number;
  url: string;
  provider: SegmentProvider;
  rawPayload: SegmentBatchEvent;
}

export type SegmentProvider = 'segment' | 'rudderstack' | 'dreamdata' | 'unknown';
```

## Interception Strategy

### Background Script Setup

The background script uses `webRequest.onBeforeRequest` to intercept POST requests to Segment endpoints:

```typescript
// src/pages/background/index.ts
import Browser from 'webextension-polyfill';
import {
  SEGMENT_ENDPOINTS,
  decodeRequestBody,
  detectProvider,
  parseSegmentPayload,
  processBatchPayload,
} from '@src/lib/segment';

Browser.webRequest.onBeforeRequest.addListener(
  handleRequest,
  { urls: [...SEGMENT_ENDPOINTS] },
  ['requestBody']  // Required to access request body
);

function handleRequest(
  details: Browser.WebRequest.OnBeforeRequestDetailsType
): void {
  // Only process POST requests with a body
  if (details.method !== 'POST') return;
  if (!details.requestBody?.raw) return;
  if (details.tabId < 0) return; // Ignore non-tab requests

  // Decode the request body
  const bodyString = decodeRequestBody(details.requestBody.raw);
  if (!bodyString) return;

  // Parse the Segment payload
  const payload = parseSegmentPayload(bodyString);
  if (!payload) return;

  // Detect the provider
  const provider = detectProvider(details.url);

  // Process the batch into normalized events
  const events = processBatchPayload(
    payload,
    details.tabId,
    details.url,
    provider
  );

  // Store and notify listeners
  storeEvents(details.tabId, events);
  notifyListeners(details.tabId, events);
}
```

### Decoding Request Body

The webRequest API provides the body as an array of `UploadData` objects:

```typescript
// src/lib/segment.ts
export function decodeRequestBody(
  raw: Array<{ bytes?: unknown; file?: string }>
): string | null {
  if (!raw || raw.length === 0) return null;

  try {
    const decoder = new TextDecoder('utf-8');
    const parts = raw
      .filter((part) => part.bytes instanceof ArrayBuffer)
      .map((part) => decoder.decode(part.bytes as ArrayBuffer));
    return parts.join('');
  } catch {
    console.error('[analytics-x-ray] Failed to decode request body');
    return null;
  }
}
```

## Message Passing

### Message Types

```typescript
interface ExtensionMessage {
  type: 'GET_EVENTS' | 'CLEAR_EVENTS' | 'GET_EVENT_COUNT' | 'EVENTS_CAPTURED';
  tabId?: number;
  payload?: unknown;
}
```

### Requesting Events (from DevTools/Popup)

```typescript
// Get events for current tab
const events = await Browser.runtime.sendMessage({
  type: 'GET_EVENTS',
  tabId: currentTabId,
});

// Clear events for current tab
await Browser.runtime.sendMessage({
  type: 'CLEAR_EVENTS',
  tabId: currentTabId,
});
```

### Listening for New Events

```typescript
Browser.runtime.onMessage.addListener((message) => {
  if (message.type === 'EVENTS_CAPTURED') {
    const { tabId, events } = message.payload;
    // Update UI with new events
  }
});
```

## Event Display Formatting

```typescript
// Get display name for an event
export function getEventName(event: SegmentBatchEvent): string {
  switch (event.type) {
    case 'track':
      return event.event || 'Unnamed Track';
    case 'page':
      return event.name ? `Page: ${event.name}` : 'Page View';
    case 'screen':
      return event.name ? `Screen: ${event.name}` : 'Screen View';
    case 'identify':
      return event.userId ? `Identify: ${event.userId}` : 'Identify';
    case 'group':
      return 'Group';
    case 'alias':
      return 'Alias';
    default:
      return 'Unknown';
  }
}

// Badge colors for event types
const EVENT_COLORS: Record<SegmentEventType, string> = {
  track: 'bg-blue-500',
  page: 'bg-green-500',
  screen: 'bg-teal-500',
  identify: 'bg-purple-500',
  group: 'bg-amber-500',
  alias: 'bg-gray-500',
};
```

## Manifest Configuration

Required permissions for network interception:

```json
{
  "permissions": [
    "webRequest",
    "storage",
    "tabs"
  ],
  "host_permissions": [
    "*://api.segment.io/*",
    "*://api.segment.com/*",
    "*://*.rudderstack.com/*",
    "*://tracking.dreamdata.cloud/*"
  ]
}
```

## Storage Strategy

Events are stored both in-memory and persisted to `Browser.storage.local`:

```typescript
// In-memory for fast access
const tabEvents = new Map<number, SegmentEvent[]>();

// Persisted for service worker restarts
interface StoredEvents {
  [tabId: number]: SegmentEvent[];
}

// Store events
async function storeEvents(tabId: number, newEvents: SegmentEvent[]) {
  // Update memory
  const existing = tabEvents.get(tabId) || [];
  const updated = [...newEvents, ...existing].slice(0, MAX_EVENTS_PER_TAB);
  tabEvents.set(tabId, updated);

  // Persist to storage
  const result = await Browser.storage.local.get('events');
  const events: StoredEvents = (result.events as StoredEvents) || {};
  events[tabId] = updated;
  await Browser.storage.local.set({ events });
}
```

## Security Considerations

```typescript
// ✅ Validate batch events before processing
export function isValidBatchEvent(event: unknown): event is SegmentBatchEvent {
  if (typeof event !== 'object' || event === null) return false;
  const e = event as Record<string, unknown>;
  return (
    typeof e.type === 'string' &&
    ['track', 'page', 'screen', 'identify', 'group', 'alias'].includes(e.type) &&
    typeof e.messageId === 'string'
  );
}

// ✅ Type guard for payload structure
function isSegmentPayload(payload: unknown): payload is SegmentBatchPayload {
  if (typeof payload !== 'object' || payload === null) return false;
  const p = payload as Record<string, unknown>;
  if (!Array.isArray(p.batch)) return false;
  if (p.batch.length === 0) return false;
  return true;
}
```

## Cleanup

Clean up when tabs close to prevent memory leaks:

```typescript
Browser.tabs.onRemoved.addListener(async (tabId) => {
  // Clear memory
  tabEvents.delete(tabId);

  // Clear storage
  const result = await Browser.storage.local.get('events');
  const events: StoredEvents = (result.events as StoredEvents) || {};
  delete events[tabId];
  await Browser.storage.local.set({ events });
});
```
